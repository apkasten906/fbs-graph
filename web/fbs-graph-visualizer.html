<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FBS Schedule Graph — Teams & Matchups</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="stylesheet" href="common-theme.css" />
    <link rel="stylesheet" href="css/shared-nav.css" />
    <style>
      /* Adjust body for nav offset */
      body {
        margin-left: 220px;
        transition: margin-left 0.3s ease;
      }

      body.nav-collapsed {
        margin-left: 0;
      }

      * {
        box-sizing: border-box;
      }
      header {
        padding: 10px 12px;
        background: linear-gradient(90deg, #0e1631, #151f43);
        border-bottom: 1px solid #26335f;
        position: sticky;
        top: 0;
        z-index: 5;
      }
      header h1 {
        font-size: 16px;
        margin: 0 0 6px;
        letter-spacing: 0.3px;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      .controls label {
        font-size: 12px;
        color: var(--muted);
      }
      .controls input,
      .controls select,
      .controls button {
        background: #0d1634;
        color: var(--ink);
        border: 1px solid #23315e;
        border-radius: 8px;
        padding: 6px 8px;
        font-size: 12px;
      }
      .controls input[type='range'] {
        width: 160px;
      }
      .controls button {
        cursor: pointer;
        transition: 0.2s background;
      }
      .controls button:hover {
        background: #112058;
      }
      main {
        display: flex;
        height: calc(100vh - 72px);
      }
      #sidebar {
        width: 320px;
        border-right: 1px solid #26335f;
        background: var(--panel);
        padding: 10px;
        overflow: auto;
      }
      #cy {
        flex: 1;
      }
      .legend {
        font-size: 12px;
        display: grid;
        grid-template-columns: 14px 1fr;
        gap: 8px 8px;
        align-items: center;
      }
      .dot {
        width: 12px;
        height: 12px;
        border-radius: 999px;
      }
      .muted {
        color: var(--muted);
      }
      .section {
        margin-bottom: 12px;
      }
      .small {
        font-size: 12px;
      }
      .pathlist {
        font-size: 12px;
        line-height: 1.35;
        max-height: 180px;
        overflow: auto;
        background: #0c1430;
        padding: 8px;
        border: 1px solid #23315e;
        border-radius: 8px;
      }
      .mono {
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New',
          monospace;
      }
      footer {
        position: fixed;
        bottom: 10px;
        left: 10px;
        z-index: 10;
        font-size: 12px;
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <header>
      <h1>FBS Schedule Graph — Teams & Matchups</h1>
      <div class="controls">
        <label>Season:</label>
        <input id="season" type="number" value="2025" style="width: 80px" />
        <label>Type:</label>
        <select id="typeFilter">
          <option value="ALL" selected>All</option>
          <option value="NON_CONFERENCE">Non-Conference</option>
          <option value="CONFERENCE">Conference</option>
        </select>
        <label>Min leverage:</label>
        <input id="lev" type="range" min="0" max="1.2" step="0.01" value="0" />
        <span id="levVal" class="muted small">0</span>
        <button id="loadBtn">Reload</button>
        <button id="fitBtn">Fit</button>
      </div>
    </header>

    <main>
      <aside id="sidebar">
        <div class="section">
          <div class="muted small">
            Compare teams (show all paths within degrees of separation):
          </div>
          <div
            style="display: flex; gap: 6px; margin-top: 6px; flex-wrap: wrap; align-items: flex-end"
          >
            <select id="srcSel"></select>
            <select id="dstSel"></select>
          </div>
          <div style="display: flex; gap: 8px; margin-top: 8px; align-items: center">
            <label style="font-size: 11px">Degrees:</label>
            <input
              id="degrees"
              type="range"
              min="0"
              max="6"
              step="1"
              value="1"
              style="width: 100px"
            />
            <span id="degreesVal" class="muted small">1</span>
          </div>
          <div style="margin-top: 8px">
            <button id="pathBtn">Show Comparisons</button>
          </div>
          <div id="pathInfo" class="pathlist" style="margin-top: 8px">
            Select teams and click "Show Comparisons".
          </div>
        </div>
        <div class="section">
          <div class="muted small">Legend / Conferences</div>
          <div id="legend" class="legend" style="margin-top: 6px"></div>
        </div>
        <div class="section small muted">
          Tip: drag nodes, wheel to zoom. Click an edge to see the games that create that
          connection.
        </div>
      </aside>
      <div id="cy"></div>
    </main>

    <footer class="small">Edit endpoint if your server runs elsewhere; set season; Reload.</footer>

    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    <script type="module">
      // Expose centralized GraphQL endpoint to non-module scripts
      import { DEFAULT_GRAPHQL_ENDPOINT } from './modules/config.js';
      window.GRAPHQL_ENDPOINT = DEFAULT_GRAPHQL_ENDPOINT;

      // Import graph path-finding algorithms
      import {
        edgeKey,
        buildAdjacencyList,
        shortestPathByInverseLeverage as spbil,
        findNodesWithinDegrees as fnwd,
      } from './modules/graph-path-finder.js';

      // Expose to non-module scripts
      window.edgeKey = edgeKey;
      window.buildAdjacencyList = buildAdjacencyList;
      window.shortestPathByInverseLeverage = spbil;
      window.findNodesWithinDegrees = fnwd;

      // Import Cytoscape builder functions
      import {
        COLORS as BUILDER_COLORS,
        buildGraphElements,
        calculateDegreePositions as calcDegPos,
        createCytoscapeStyle,
        createLayoutConfig,
      } from './modules/cytoscape-builder.js';

      // Expose builder functions to non-module scripts
      window.BUILDER_COLORS = BUILDER_COLORS;
      window.buildGraphElements = buildGraphElements;
      window.calculateDegreePositions = calcDegPos;
      window.createCytoscapeStyle = createCytoscapeStyle;
      window.createLayoutConfig = createLayoutConfig;
    </script>
    <script>
      // Use COLORS from builder module
      const COLORS = window.BUILDER_COLORS;

      const QUERY = `
query Graph($season: Int!) {
  teams(season: $season) {
    id name shortName conference { id shortName }
  }
  games(season: $season) {
    id type leverage date
    home { id name conference { id shortName } }
    away { id name conference { id shortName } }
  }
}`;

      const POST = (url, body) =>
        fetch(url, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(body),
        }).then(r => r.json());

      let cy;
      let graphData = { teams: [], games: [] };
      let pairGames = new Map(); // key "a__b" -> array of games
      let teamIndex = new Map();

      // Inline key function (edgeKey equivalent) for immediate availability
      function key(a, b) {
        return a < b ? `${a}__${b}` : `${b}__${a}`;
      }

      function buildGraph(season, typeFilter, minLev, pathFilter = null) {
        console.log('buildGraph called with pathFilter:', pathFilter);

        // Build graph elements using builder module
        const els = window.buildGraphElements({
          teams: graphData.teams,
          games: graphData.games,
          teamIndex,
          pairGames,
          typeFilter,
          minLeverage: minLev,
          pathFilter,
        });

        // Get container dimensions for layout
        const container = document.getElementById('cy');
        const width = container.offsetWidth || 800;
        const height = container.offsetHeight || 600;

        // Init / update Cytoscape
        if (!cy) {
          cy = cytoscape({
            container,
            elements: els,
            layout: window.createLayoutConfig(pathFilter, width, height),
            style: window.createCytoscapeStyle(),
          });
          cy.on('tap', 'edge', e => showEdgeGames(e.target.data()));
        } else {
          cy.elements().remove();
          cy.add(els);
          // Re-register edge click handler
          cy.off('tap', 'edge');
          cy.on('tap', 'edge', e => showEdgeGames(e.target.data()));
        }

        // Compute degree for sizing
        cy.nodes().forEach(n => {
          n.data('deg', n.connectedEdges().length);
        });

        // Apply layout
        cy.layout(window.createLayoutConfig(pathFilter, width, height)).run();
      }

      function showEdgeGames(data) {
        const { id } = data;
        const [_, k] = id.split('e_');
        const games = pairGames.get(k) || [];
        const container = document.getElementById('pathInfo');
        // Build DOM nodes instead of using innerHTML to avoid XSS and ensure safe updates
        const frag = document.createDocumentFragment();
        const header = document.createElement('div');
        header.className = 'small muted';
        header.textContent = `Games on this connection (${games.length}):`;
        frag.appendChild(header);
        for (const g of games.slice().sort((a, b) => (a.date || '').localeCompare(b.date || ''))) {
          const when = g.date ? new Date(g.date).toLocaleString() : 'TBD';
          const row = document.createElement('div');
          row.className = 'mono';
          row.textContent = `${when} — ${g.home.name} vs ${g.away.name} `;
          const lev = document.createElement('span');
          lev.className = 'muted';
          lev.textContent = `(lev ${Number(g.leverage || 0).toFixed(3)})`;
          row.appendChild(lev);
          frag.appendChild(row);
        }
        container.replaceChildren(frag);
      }

      // Conference metadata cache (populated from GraphQL)
      let conferenceMeta = [];

      function buildLegend() {
        const container = document.getElementById('legend');
        container.replaceChildren();
        const seen = new Set();
        // Collect all conferences present in the data
        for (const t of graphData.teams) {
          const conf = (t.conference && t.conference.id) || 'other';
          seen.add(conf);
        }
        // Map to full names, filter, and sort
        const legendEntries = Array.from(seen)
          .map(id => {
            const meta = conferenceMeta.find(c => c.id === id);
            return {
              id,
              color: COLORS[id] || COLORS.other,
              label: meta ? `${meta.name} (${meta.shortName})` : id.toUpperCase(),
              sortKey: meta ? meta.name : id,
            };
          })
          .sort((a, b) => a.sortKey.localeCompare(b.sortKey));
        for (const entry of legendEntries) {
          const dot = document.createElement('div');
          dot.className = 'dot';
          dot.style.background = entry.color;
          const lbl = document.createElement('div');
          lbl.textContent = entry.label;
          container.appendChild(dot);
          container.appendChild(lbl);
        }
      }

      function buildSelectors() {
        const srcSel = document.getElementById('srcSel');
        const dstSel = document.getElementById('dstSel');
        const opts = graphData.teams.slice().sort((a, b) => a.name.localeCompare(b.name));
        srcSel.replaceChildren();
        dstSel.replaceChildren();
        for (const t of opts) {
          const o1 = document.createElement('option');
          o1.value = t.id;
          o1.textContent = t.name;
          srcSel.appendChild(o1);
          const o2 = document.createElement('option');
          o2.value = t.id;
          o2.textContent = t.name;
          dstSel.appendChild(o2);
        }
        // Set default selections: OSU and Georgia
        // Try common IDs, fallback to first if not found
        const osuId =
          opts.find(t => t.name.toLowerCase().includes('ohio state'))?.id || opts[0]?.id;
        const ugaId = opts.find(t => t.name.toLowerCase().includes('georgia'))?.id || opts[1]?.id;
        if (osuId) srcSel.value = osuId;
        if (ugaId) dstSel.value = ugaId;

        // Auto-trigger comparison with default selections
        setTimeout(() => {
          document.getElementById('pathBtn').click();
        }, 100);
      }

      // Adapter functions that call the imported module functions with correct parameters
      // Use different names to avoid collision with window.* properties
      function _shortestPath(srcId, dstId, typeFilter, minLev) {
        if (!window.shortestPathByInverseLeverage) {
          console.error('shortestPathByInverseLeverage not loaded from module yet');
          return null;
        }
        return window.shortestPathByInverseLeverage(
          srcId,
          dstId,
          pairGames,
          graphData.teams,
          typeFilter,
          minLev
        );
      }

      function _findNodesWithinDegrees(startNodes, maxDegrees, typeFilter, minLev, shortestPath) {
        if (!window.findNodesWithinDegrees) {
          console.error('findNodesWithinDegrees not loaded from module yet');
          return { nodes: [], edges: [], nodesByDegree: new Map(), source: startNodes[0], destination: startNodes[1] };
        }
        // Module signature: findNodesWithinDegrees(startNodes, maxDegrees, pairGames, teams, typeFilter, minLev, shortestPath)
        return window.findNodesWithinDegrees(
          startNodes,
          maxDegrees,
          pairGames,
          graphData.teams,
          typeFilter,
          minLev,
          shortestPath
        );
      }

      const CONFERENCES_QUERY = `
        query { conferences { id name shortName } }
      `;

      async function load() {
        const season = Number(document.getElementById('season').value);

        // Use static data adapter if available, otherwise fall back to GraphQL
        if (window.staticDataAdapter) {
          try {
            const [conferences, result] = await Promise.all([
              window.staticDataAdapter.getConferences(),
              window.staticDataAdapter.queryGraph(season),
            ]);
            conferenceMeta = conferences || [];
            graphData = result.data;
          } catch (error) {
            alert('Error loading static data: ' + error.message);
            return;
          }
        } else {
          // Fallback to GraphQL if static data not available
          const endpoint =
            document.getElementById('endpoint')?.value?.trim() || window.GRAPHQL_ENDPOINT;
          const confRes = await POST(endpoint, { query: CONFERENCES_QUERY });
          if (confRes.errors) {
            alert('GraphQL error (conferences): ' + JSON.stringify(confRes.errors[0], null, 2));
            return;
          }
          conferenceMeta = confRes.data.conferences || [];
          const res = await POST(endpoint, { query: QUERY, variables: { season } });
          if (res.errors) {
            alert('GraphQL error: ' + JSON.stringify(res.errors[0], null, 2));
            return;
          }
          graphData = res.data;
        }

        buildLegend();
        buildSelectors();
        applyFilters();
      }

      function applyFilters() {
        const typeFilter = document.getElementById('typeFilter').value;
        const minLev = Number(document.getElementById('lev').value);
        document.getElementById('levVal').textContent = String(minLev);
        // Clear path filter when applying filters (show all teams again)
        buildGraph(Number(document.getElementById('season').value), typeFilter, minLev, null);
      }

      document.getElementById('loadBtn').addEventListener('click', load);
      document.getElementById('fitBtn').addEventListener('click', () => cy && cy.fit());
      document.getElementById('lev').addEventListener('input', applyFilters);
      document.getElementById('typeFilter').addEventListener('change', applyFilters);
      document.getElementById('degrees').addEventListener('input', e => {
        document.getElementById('degreesVal').textContent = e.target.value;
      });
      document.getElementById('pathBtn').addEventListener('click', () => {
        const typeFilter = document.getElementById('typeFilter').value;
        const minLev = Number(document.getElementById('lev').value);
        const src = document.getElementById('srcSel').value;
        const dst = document.getElementById('dstSel').value;
        const box = document.getElementById('pathInfo');

        if (!src || !dst) {
          box.textContent = 'Please select both teams.';
          return;
        }

        // First, find the shortest path to determine the minimum degrees needed
        const shortestPath = _shortestPath(src, dst, typeFilter, minLev);

        if (!shortestPath || shortestPath.nodes.length === 0) {
          box.textContent = 'No path found between these teams (maybe filters are too strict).';
          return;
        }

        // Calculate the number of hops in the shortest path
        // Path nodes include source and dest, so hops = nodes - 1
        const shortestPathHops = shortestPath.nodes.length - 1;

        // Determine appropriate degrees to show based on shortest path
        // If direct connection (1 hop), show degree 1 to see common opponents too
        // Otherwise, show the exact number of hops in the shortest path
        const suggestedDegrees = shortestPathHops === 1 ? 1 : shortestPathHops;

        // Update the degree slider to match the shortest path
        const degreesSlider = document.getElementById('degrees');
        degreesSlider.value = suggestedDegrees;
        document.getElementById('degreesVal').textContent = suggestedDegrees;

        const degrees = suggestedDegrees;

        // Find all nodes within N degrees of both selected teams
        // Pass the shortest path to ensure it's always included
        const res = _findNodesWithinDegrees(
          [src, dst],
          degrees,
          typeFilter,
          minLev,
          shortestPath
        );

        if (!res || res.nodes.length === 0) {
          box.textContent = 'No connections found (maybe filters are too strict).';
          return;
        }

        // Rebuild graph to show teams within degrees of separation
        const season = Number(document.getElementById('season').value);
        buildGraph(season, typeFilter, minLev, res);

        // Highlight the selected teams
        cy.elements().removeClass('highlight');
        cy.getElementById(src).addClass('highlight');
        cy.getElementById(dst).addClass('highlight');
        cy.style()
          .selector('.highlight')
          .style({ 'background-color': '#facc15', 'border-width': 3, 'border-color': '#fff' })
          .update();

        // Render comparison info
        const frag = document.createDocumentFragment();
        const header = document.createElement('div');
        header.className = 'small muted';
        header.textContent = `Comparison network (${res.nodes.length} teams, ${res.edges.length} connections):`;
        frag.appendChild(header);

        const srcTeam = teamIndex.get(src);
        const dstTeam = teamIndex.get(dst);

        const summary = document.createElement('div');
        summary.style.marginTop = '8px';
        summary.innerHTML = `<strong>${srcTeam.name}</strong> vs <strong>${dstTeam.name}</strong>`;
        frag.appendChild(summary);

        // Show shortest path info
        const pathInfo = document.createElement('div');
        pathInfo.className = 'small muted';
        pathInfo.style.marginTop = '4px';
        const pathTeamNames = shortestPath.nodes.map(id => teamIndex.get(id)?.name || id);
        pathInfo.textContent = `Shortest path (${shortestPathHops} hop${shortestPathHops !== 1 ? 's' : ''}): ${pathTeamNames.join(' → ')}`;
        frag.appendChild(pathInfo);

        // Count teams by degree
        const degreeCount = new Map();
        for (const [node, deg] of res.nodesByDegree) {
          degreeCount.set(deg, (degreeCount.get(deg) || 0) + 1);
        }

        const degreeInfo = document.createElement('div');
        degreeInfo.className = 'small muted';
        degreeInfo.style.marginTop = '6px';
        const degreeParts = [];
        for (let d = 0; d <= degrees; d++) {
          const count = degreeCount.get(d) || 0;
          if (count > 0) {
            degreeParts.push(`${count} at ${d}°`);
          }
        }
        degreeInfo.textContent = 'Distribution: ' + degreeParts.join(', ');
        frag.appendChild(degreeInfo);

        box.replaceChildren(frag);
      });

      // Auto-load will be triggered after static data adapter loads
    </script>
    <script type="module">
      // Load static data adapter first
      import { staticData } from './modules/static-data-adapter.js';
      window.staticDataAdapter = staticData;
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        console.log('[Visualizer] Static data adapter initialized');
      }

      // Trigger the load function that was defined in the previous script
      load();
    </script>
    <script type="module">
      import { initNavigation } from './modules/shared-nav.js';
      initNavigation('fbs-graph');
    </script>
  </body>
</html>
