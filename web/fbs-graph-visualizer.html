<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FBS Schedule Graph — Teams & Matchups</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="stylesheet" href="common-theme.css" />
    <link rel="stylesheet" href="css/shared-nav.css" />
    <style>
      /* Adjust body for nav offset */
      body {
        margin-left: 220px;
        transition: margin-left 0.3s ease;
      }

      body.nav-collapsed {
        margin-left: 0;
      }

      * {
        box-sizing: border-box;
      }
      header {
        padding: 10px 12px;
        background: linear-gradient(90deg, #0e1631, #151f43);
        border-bottom: 1px solid #26335f;
        position: sticky;
        top: 0;
        z-index: 5;
      }
      header h1 {
        font-size: 16px;
        margin: 0 0 6px;
        letter-spacing: 0.3px;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      .controls label {
        font-size: 12px;
        color: var(--muted);
      }
      .controls input,
      .controls select,
      .controls button {
        background: #0d1634;
        color: var(--ink);
        border: 1px solid #23315e;
        border-radius: 8px;
        padding: 6px 8px;
        font-size: 12px;
      }
      .controls input[type='range'] {
        width: 160px;
      }
      .controls button {
        cursor: pointer;
        transition: 0.2s background;
      }
      .controls button:hover {
        background: #112058;
      }
      main {
        display: flex;
        height: calc(100vh - 72px);
      }
      #sidebar {
        width: 320px;
        border-right: 1px solid #26335f;
        background: var(--panel);
        padding: 10px;
        overflow: auto;
      }
      #cy {
        flex: 1;
      }
      .legend {
        font-size: 12px;
        display: grid;
        grid-template-columns: 14px 1fr;
        gap: 8px 8px;
        align-items: center;
      }
      .dot {
        width: 12px;
        height: 12px;
        border-radius: 999px;
      }
      .muted {
        color: var(--muted);
      }
      .section {
        margin-bottom: 12px;
      }
      .small {
        font-size: 12px;
      }
      .pathlist {
        font-size: 12px;
        line-height: 1.35;
        max-height: 180px;
        overflow: auto;
        background: #0c1430;
        padding: 8px;
        border: 1px solid #23315e;
        border-radius: 8px;
      }
      .mono {
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New',
          monospace;
      }
      footer {
        position: fixed;
        bottom: 10px;
        left: 10px;
        z-index: 10;
        font-size: 12px;
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <header>
      <h1>FBS Schedule Graph — Teams & Matchups</h1>
      <div class="controls">
        <label>Season:</label>
        <input id="season" type="number" value="2025" style="width: 80px" />
        <label>Type:</label>
        <select id="typeFilter">
          <option value="ALL" selected>All</option>
          <option value="NON_CONFERENCE">Non-Conference</option>
          <option value="CONFERENCE">Conference</option>
        </select>
        <label>Min leverage:</label>
        <input id="lev" type="range" min="0" max="1.2" step="0.01" value="0" />
        <span id="levVal" class="muted small">0</span>
        <button id="loadBtn">Reload</button>
        <button id="fitBtn">Fit</button>
      </div>
    </header>

    <main>
      <aside id="sidebar">
        <div class="section">
          <div class="muted small">
            Compare teams (show all paths within degrees of separation):
          </div>
          <div
            style="display: flex; gap: 6px; margin-top: 6px; flex-wrap: wrap; align-items: flex-end"
          >
            <select id="srcSel"></select>
            <select id="dstSel"></select>
          </div>
          <div style="display: flex; gap: 8px; margin-top: 8px; align-items: center">
            <label style="font-size: 11px">Degrees:</label>
            <input
              id="degrees"
              type="range"
              min="0"
              max="6"
              step="1"
              value="1"
              style="width: 100px"
            />
            <span id="degreesVal" class="muted small">1</span>
          </div>
          <div style="margin-top: 8px">
            <button id="pathBtn">Show Comparisons</button>
          </div>
          <div id="pathInfo" class="pathlist" style="margin-top: 8px">
            Select teams and click "Show Comparisons".
          </div>
        </div>
        <div class="section">
          <div class="muted small">Legend / Conferences</div>
          <div id="legend" class="legend" style="margin-top: 6px"></div>
        </div>
        <div class="section small muted">
          Tip: drag nodes, wheel to zoom. Click an edge to see the games that create that
          connection.
        </div>
      </aside>
      <div id="cy"></div>
    </main>

    <footer class="small">Edit endpoint if your server runs elsewhere; set season; Reload.</footer>

    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    <script type="module">
      // Expose centralized GraphQL endpoint to non-module scripts
      import { GRAPHQL_ENDPOINT } from './modules/config.js';
      window.GRAPHQL_ENDPOINT = GRAPHQL_ENDPOINT;
    </script>
    <script>
      const COLORS = {
        sec: '#6CCFF6',
        b1g: '#B28DFF',
        b12: '#F6AE2D',
        acc: '#4CC9F0',
        aac: '#FF6B6B',
        mwc: '#80ED99',
        mac: '#FFD166',
        sbc: '#90CAF9',
        cusa: '#FF9E00',
        ind: '#BDB2FF',
        pac12: '#9CCC65',
        other: '#CCD6F6',
      };

      const QUERY = `
query Graph($season: Int!) {
  teams(season: $season) {
    id name shortName conference { id shortName }
  }
  games(season: $season) {
    id type leverage date
    home { id name conference { id shortName } }
    away { id name conference { id shortName } }
  }
}`;

      const POST = (url, body) =>
        fetch(url, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(body),
        }).then(r => r.json());

      let cy;
      let graphData = { teams: [], games: [] };
      let pairGames = new Map(); // key "a__b" -> array of games
      let teamIndex = new Map();

      function key(a, b) {
        return a < b ? a + '__' + b : b + '__' + a;
      }

      function buildGraph(season, typeFilter, minLev, pathFilter = null) {
        console.log('buildGraph called with pathFilter:', pathFilter);
        const els = [];
        teamIndex.clear();
        graphData.teams.forEach(t => teamIndex.set(t.id, t));

        // Filter teams to show (all or just path nodes)
        const teamsToShow = pathFilter
          ? graphData.teams.filter(t => pathFilter.nodes.includes(t.id))
          : graphData.teams;

        // Nodes
        for (const t of teamsToShow) {
          const conf = (t.conference && t.conference.id) || 'other';
          els.push({
            group: 'nodes',
            data: { id: t.id, label: t.name, conf },
            classes: conf,
          });
        }

        // Edge aggregation by pair
        pairGames.clear();
        const edges = new Map();
        for (const g of graphData.games) {
          if (typeFilter !== 'ALL' && g.type !== typeFilter) continue;
          const lev = typeof g.leverage === 'number' ? g.leverage : 0;
          if (lev < minLev) continue;
          const a = g.home.id,
            b = g.away.id;
          if (!teamIndex.has(a) || !teamIndex.has(b)) continue;
          const k = key(a, b);
          const arr = pairGames.get(k) || [];
          arr.push(g);
          pairGames.set(k, arr);
        }

        const degreeColors = [
          '#00FF00', // 0: Bright Green (direct connection)
          '#FFFF00', // 1: Bright Yellow (1 hop)
          '#FFA500', // 2: Orange (2 hops)
          '#FF6B35', // 3: Orange-Red (3 hops)
          '#FF4500', // 4: Red-Orange (4 hops)
          '#DC143C', // 5: Crimson (5 hops)
          '#8B0000', // 6: Dark Red (6 hops)
        ];

        for (const [k, list] of pairGames) {
          // Skip edge if pathFilter is active and edge is not in path
          if (pathFilter && !pathFilter.edges.includes(k)) continue;

          // compute edge weight
          const a = list[0].home.id,
            b = list[0].away.id;
          const sumLev = list.reduce((s, x) => s + (x.leverage || 0), 0);
          const avgLev = sumLev / list.length;
          const w = Math.max(1, Math.log2(1 + sumLev * 4));

          // Calculate edge color based on degree of separation in the comparison path
          let edgeColor = '#4562aa'; // Default blue
          if (
            pathFilter &&
            pathFilter.nodesByDegree &&
            pathFilter.source &&
            pathFilter.destination
          ) {
            const degreeA = pathFilter.nodesByDegree.get(a) || 0;
            const degreeB = pathFilter.nodesByDegree.get(b) || 0;

            // The degree of an edge is the maximum degree it connects (representing how many hops from source)
            const edgeDegree = Math.max(degreeA, degreeB);
            edgeColor = degreeColors[Math.min(edgeDegree, degreeColors.length - 1)];

            // Debug logging
            console.log(
              `Edge ${a} -> ${b}: degreeA=${degreeA}, degreeB=${degreeB}, edgeDegree=${edgeDegree}, color=${edgeColor}`
            );
          }

          edges.set(k, { a, b, count: list.length, sumLev, avgLev, weight: w, edgeColor });
        }
        for (const [k, e] of edges) {
          els.push({
            group: 'edges',
            data: {
              id: 'e_' + k,
              source: e.a,
              target: e.b,
              label: `${e.count}`,
              weight: e.weight,
              avgLev: e.avgLev,
              edgeColor: e.edgeColor,
            },
          });
        }

        // Init / update Cytoscape
        if (!cy) {
          cy = cytoscape({
            container: document.getElementById('cy'),
            elements: els,
            layout: {
              name: pathFilter ? 'preset' : 'cose',
              positions: pathFilter
                ? node => {
                    const degree = pathFilter.nodesByDegree.get(node.id()) || 0;
                    // Position nodes horizontally based on their degree from source
                    // Left (x=100) for source team, right for destination team
                    const maxDegree = Math.max(...Array.from(pathFilter.nodesByDegree.values()));
                    const containerWidth = document.getElementById('cy').offsetWidth || 800;
                    const xPadding = 100;
                    const usableWidth = containerWidth - 2 * xPadding;
                    const x =
                      maxDegree > 0
                        ? xPadding + (degree / maxDegree) * usableWidth
                        : containerWidth / 2;

                    // Add some vertical jitter to prevent overlaps at same degree
                    const jitter = (Math.random() - 0.5) * 100;
                    const y = 300 + jitter;

                    return { x, y };
                  }
                : undefined,
              idealEdgeLength: edge => {
                const avgLev = edge.data('avgLev') || 0.1;
                // Higher leverage = shorter edge (inverse relationship)
                // Scale from 50 (high leverage ~1.0) to 300 (low leverage ~0.1)
                return Math.max(50, Math.min(300, 150 / Math.max(0.1, avgLev)));
              },
              nodeOverlap: 20,
              nodeRepulsion: 8000,
              fit: true,
            },
            style: [
              {
                selector: 'node',
                style: {
                  'background-color': ele => COLORS[ele.data('conf')] || COLORS.other,
                  label: 'data(label)',
                  color: '#cfe1ff',
                  'font-size': '9px',
                  'text-outline-color': '#0b1020',
                  'text-outline-width': 2,
                  width: 'mapData(deg, 0, 24, 8, 34)',
                  height: 'mapData(deg, 0, 24, 8, 34)',
                },
              },
              {
                selector: 'edge',
                style: {
                  'line-color': ele => ele.data('edgeColor') || '#4562aa',
                  width: ele => Math.max(1.5, ele.data('weight') || 1.5),
                  opacity: 0.7,
                  'curve-style': 'haystack',
                },
              },
              { selector: 'edge:selected', style: { 'line-color': '#fff', opacity: 1 } },
              {
                selector: '.highlight',
                style: { 'line-color': '#fff', 'background-color': '#fff', opacity: 1 },
              },
            ],
          });
          cy.on('tap', 'edge', e => showEdgeGames(e.target.data()));
        } else {
          cy.elements().remove();
          cy.add(els);
          // Re-register edge click handler
          cy.off('tap', 'edge');
          cy.on('tap', 'edge', e => showEdgeGames(e.target.data()));
        }

        // Compute degree for sizing
        cy.nodes().forEach(n => {
          n.data('deg', n.connectedEdges().length);
        });

        // Use preset layout for comparison view to create left-to-right flow
        console.log('Layout selection - pathFilter:', pathFilter, 'truthy?', !!pathFilter);
        if (pathFilter) {
          console.log('Using preset layout with positions');
          const positions = calculateDegreePositions(pathFilter);
          console.log('Calculated positions:', positions);

          cy.layout({
            name: 'preset',
            positions: positions,
            fit: true,
            padding: 50,
            avoidOverlap: true,
            nodeDimensionsIncludeLabels: true,
          }).run();
        } else {
          console.log('Using cose layout');
          cy.layout({
            name: 'cose',
            idealEdgeLength: edge => {
              const avgLev = edge.data('avgLev') || 0.1;
              // Higher leverage = shorter edge (inverse relationship)
              return Math.max(50, Math.min(300, 150 / Math.max(0.1, avgLev)));
            },
            nodeOverlap: 20,
            nodeRepulsion: 8000,
          }).run();
        }
      }

      function showEdgeGames(data) {
        const { id } = data;
        const [_, k] = id.split('e_');
        const games = pairGames.get(k) || [];
        const container = document.getElementById('pathInfo');
        // Build DOM nodes instead of using innerHTML to avoid XSS and ensure safe updates
        const frag = document.createDocumentFragment();
        const header = document.createElement('div');
        header.className = 'small muted';
        header.textContent = `Games on this connection (${games.length}):`;
        frag.appendChild(header);
        for (const g of games.slice().sort((a, b) => (a.date || '').localeCompare(b.date || ''))) {
          const when = g.date ? new Date(g.date).toLocaleString() : 'TBD';
          const row = document.createElement('div');
          row.className = 'mono';
          row.textContent = `${when} — ${g.home.name} vs ${g.away.name} `;
          const lev = document.createElement('span');
          lev.className = 'muted';
          lev.textContent = `(lev ${Number(g.leverage || 0).toFixed(3)})`;
          row.appendChild(lev);
          frag.appendChild(row);
        }
        container.replaceChildren(frag);
      }

      // Conference metadata cache (populated from GraphQL)
      let conferenceMeta = [];

      function buildLegend() {
        const container = document.getElementById('legend');
        container.replaceChildren();
        const seen = new Set();
        // Collect all conferences present in the data
        for (const t of graphData.teams) {
          const conf = (t.conference && t.conference.id) || 'other';
          seen.add(conf);
        }
        // Map to full names, filter, and sort
        const legendEntries = Array.from(seen)
          .map(id => {
            const meta = conferenceMeta.find(c => c.id === id);
            return {
              id,
              color: COLORS[id] || COLORS.other,
              label: meta ? `${meta.name} (${meta.shortName})` : id.toUpperCase(),
              sortKey: meta ? meta.name : id,
            };
          })
          .sort((a, b) => a.sortKey.localeCompare(b.sortKey));
        for (const entry of legendEntries) {
          const dot = document.createElement('div');
          dot.className = 'dot';
          dot.style.background = entry.color;
          const lbl = document.createElement('div');
          lbl.textContent = entry.label;
          container.appendChild(dot);
          container.appendChild(lbl);
        }
      }

      function buildSelectors() {
        const srcSel = document.getElementById('srcSel');
        const dstSel = document.getElementById('dstSel');
        const opts = graphData.teams.slice().sort((a, b) => a.name.localeCompare(b.name));
        srcSel.replaceChildren();
        dstSel.replaceChildren();
        for (const t of opts) {
          const o1 = document.createElement('option');
          o1.value = t.id;
          o1.textContent = t.name;
          srcSel.appendChild(o1);
          const o2 = document.createElement('option');
          o2.value = t.id;
          o2.textContent = t.name;
          dstSel.appendChild(o2);
        }
        // Set default selections: OSU and Georgia
        // Try common IDs, fallback to first if not found
        const osuId =
          opts.find(t => t.name.toLowerCase().includes('ohio state'))?.id || opts[0]?.id;
        const ugaId = opts.find(t => t.name.toLowerCase().includes('georgia'))?.id || opts[1]?.id;
        if (osuId) srcSel.value = osuId;
        if (ugaId) dstSel.value = ugaId;

        // Auto-trigger comparison with default selections
        setTimeout(() => {
          document.getElementById('pathBtn').click();
        }, 100);
      }

      // Calculate positions for nodes based on their degree from source
      function calculateDegreePositions(pathFilter) {
        const positions = {};
        const nodesByDegree = pathFilter.nodesByDegree;
        const source = pathFilter.source;
        const destination = pathFilter.destination;
        const maxDegree = Math.max(...nodesByDegree.values());

        // Group nodes by their degree
        const degreeGroups = new Map();
        for (const [nodeId, degree] of nodesByDegree) {
          if (!degreeGroups.has(degree)) {
            degreeGroups.set(degree, []);
          }
          degreeGroups.get(degree).push(nodeId);
        }

        const width = 800;
        const height = 600;
        const centerY = height / 2;

        // Special handling for source and destination to be on same horizontal plane
        const sourceX = 50;
        const destX = width - 50;

        positions[source] = { x: sourceX, y: centerY };
        positions[destination] = { x: destX, y: centerY };

        // Position intermediate nodes (degrees 1 to maxDegree)
        const horizontalSpacing =
          maxDegree > 0 ? (destX - sourceX) / (maxDegree + 1) : (destX - sourceX) / 2;

        for (let degree = 1; degree <= maxDegree; degree++) {
          const nodesAtDegree = (degreeGroups.get(degree) || []).filter(
            id => id !== source && id !== destination
          );
          if (nodesAtDegree.length === 0) continue;

          const x = sourceX + horizontalSpacing * degree;

          // Distribute nodes vertically, avoiding the center line where source/dest are positioned
          // Use top half and bottom half of the canvas
          const topY = centerY * 0.4; // Top boundary
          const bottomY = centerY * 1.6; // Bottom boundary
          const availableHeight = bottomY - topY - 100; // Leave space around center

          nodesAtDegree.forEach((nodeId, index) => {
            // Distribute evenly, but skip the center area
            const fraction = (index + 1) / (nodesAtDegree.length + 1);
            let y;
            if (fraction < 0.5) {
              // Top half
              y = topY + fraction * 2 * (centerY - topY - 50);
            } else {
              // Bottom half
              y = centerY + 50 + (fraction - 0.5) * 2 * (bottomY - centerY - 50);
            }
            positions[nodeId] = { x, y };
          });
        }

        console.log('calculateDegreePositions returning:', positions);
        return positions;
      }

      function findNodesWithinDegrees(
        startNodes,
        maxDegrees,
        typeFilter,
        minLev,
        shortestPath = null
      ) {
        // For comparison view, we want to find paths that connect the two selected teams
        const source = startNodes[0];
        const dest = startNodes[1];

        // Build adjacency list from filtered edges
        const adj = new Map();
        for (const [k, list] of pairGames) {
          const a = list[0].home.id,
            b = list[0].away.id;
          const filtered = list.filter(
            g => (typeFilter === 'ALL' || g.type === typeFilter) && (g.leverage || 0) >= minLev
          );
          if (!filtered.length) continue;
          if (!adj.has(a)) adj.set(a, []);
          if (!adj.has(b)) adj.set(b, []);
          adj.get(a).push({ to: b, k });
          adj.get(b).push({ to: a, k });
        }

        // Special case: degree 0 means direct matchup only
        if (maxDegrees === 0) {
          const directKey = key(source, dest);
          if (pairGames.has(directKey)) {
            return {
              nodes: [source, dest],
              edges: [directKey],
              nodesByDegree: new Map([
                [source, 0],
                [dest, 0],
              ]),
              source,
              destination: dest,
            };
          }
          return { nodes: [], edges: [], nodesByDegree: new Map() };
        }

        // Build valid paths layer by layer
        // Layer 0: source and dest
        // Layer 1: common opponents (reachable from both within 1 hop)
        // Layer 2: teams that connect layer 1 teams back to source/dest

        const nodesByDegree = new Map();
        const validEdges = new Set();
        const validNodes = new Set([source, dest]);
        nodesByDegree.set(source, 0);
        nodesByDegree.set(dest, 0);

        // If we have a shortest path, ensure all its nodes and edges are included
        if (shortestPath && shortestPath.nodes && shortestPath.edges) {
          for (let i = 0; i < shortestPath.nodes.length; i++) {
            const nodeId = shortestPath.nodes[i];
            validNodes.add(nodeId);
            // Assign degree based on distance from source
            if (!nodesByDegree.has(nodeId)) {
              nodesByDegree.set(nodeId, i);
            }
          }
          for (const edgeKey of shortestPath.edges) {
            validEdges.add(edgeKey);
          }
        }

        // Find direct connection if it exists
        const directKey = key(source, dest);
        if (pairGames.has(directKey)) {
          validEdges.add(directKey);
        }

        // Layer 1: Find common opponents (teams that played both source and dest)
        const sourceNeighbors = new Set((adj.get(source) || []).map(e => e.to));
        const destNeighbors = new Set((adj.get(dest) || []).map(e => e.to));

        for (const node of sourceNeighbors) {
          if (destNeighbors.has(node)) {
            // This is a common opponent
            validNodes.add(node);
            nodesByDegree.set(node, 1);
            validEdges.add(key(source, node));
            validEdges.add(key(dest, node));
          }
        }

        // Layer 2 and beyond: Find teams that bridge between layer 1 teams and source/dest
        if (maxDegrees >= 2) {
          // For each degree 1 team, find their neighbors
          const degree1Teams = Array.from(validNodes).filter(n => nodesByDegree.get(n) === 1);

          for (const team1 of degree1Teams) {
            const neighbors = (adj.get(team1) || []).map(e => e.to);

            for (const neighbor of neighbors) {
              if (validNodes.has(neighbor)) continue; // Already included

              // Check if this neighbor connects back to source or dest
              const neighborNeighbors = new Set((adj.get(neighbor) || []).map(e => e.to));

              if (neighborNeighbors.has(source) || neighborNeighbors.has(dest)) {
                // This neighbor connects back to source or dest through team1
                validNodes.add(neighbor);
                nodesByDegree.set(neighbor, 2);
                validEdges.add(key(team1, neighbor));

                // Add edge to source or dest if it exists
                if (neighborNeighbors.has(source)) {
                  validEdges.add(key(neighbor, source));
                }
                if (neighborNeighbors.has(dest)) {
                  validEdges.add(key(neighbor, dest));
                }
              }
            }
          }
        }

        return {
          nodes: Array.from(validNodes),
          edges: Array.from(validEdges),
          nodesByDegree,
          source,
          destination: dest,
        };
      }

      function shortestPathByInverseLeverage(srcId, dstId, typeFilter, minLev) {
        // Build adjacency with weight = 1 / (avg leverage of pair). If multiple games per pair, we use avg.
        const adj = new Map();
        for (const [k, list] of pairGames) {
          const a = list[0].home.id,
            b = list[0].away.id;
          const filtered = list.filter(
            g => (typeFilter === 'ALL' || g.type === typeFilter) && (g.leverage || 0) >= minLev
          );
          if (!filtered.length) continue;
          const avg = filtered.reduce((s, x) => s + (x.leverage || 0), 0) / filtered.length;
          const w = 1 / Math.max(1e-6, avg);
          if (!adj.has(a)) adj.set(a, []);
          if (!adj.has(b)) adj.set(b, []);
          adj.get(a).push({ to: b, k, w, avg, games: filtered });
          adj.get(b).push({ to: a, k, w, avg, games: filtered });
        }
        // Dijkstra
        const dist = new Map(),
          prev = new Map(),
          prevEdge = new Map();
        const allIds = Array.from(graphData.teams, t => t.id);
        const Q = new Set(allIds);
        for (const id of allIds) dist.set(id, Infinity);
        dist.set(srcId, 0);
        while (Q.size) {
          let u = null,
            best = Infinity;
          for (const v of Q) {
            const d = dist.get(v);
            if (d < best) {
              best = d;
              u = v;
            }
          }
          if (u === null || best === Infinity) break;
          Q.delete(u);
          if (u === dstId) break;
          const nbrs = adj.get(u) || [];
          for (const e of nbrs) {
            if (!Q.has(e.to)) continue;
            const alt = dist.get(u) + e.w;
            if (alt < dist.get(e.to)) {
              dist.set(e.to, alt);
              prev.set(e.to, u);
              prevEdge.set(e.to, e.k);
            }
          }
        }
        if (!prev.has(dstId)) return null;
        // Rebuild path
        const pathIds = [];
        const edges = [];
        let cur = dstId;
        while (cur !== srcId) {
          pathIds.push(cur);
          edges.push(prevEdge.get(cur));
          cur = prev.get(cur);
        }
        pathIds.push(srcId);
        pathIds.reverse();
        edges.reverse();
        return { nodes: pathIds, edges };
      }

      const CONFERENCES_QUERY = `
        query { conferences { id name shortName } }
      `;

      async function load() {
        const season = Number(document.getElementById('season').value);

        // Use static data adapter if available, otherwise fall back to GraphQL
        if (window.staticDataAdapter) {
          try {
            const [conferences, result] = await Promise.all([
              window.staticDataAdapter.getConferences(),
              window.staticDataAdapter.queryGraph(season),
            ]);
            conferenceMeta = conferences || [];
            graphData = result.data;
          } catch (error) {
            alert('Error loading static data: ' + error.message);
            return;
          }
        } else {
          // Fallback to GraphQL if static data not available
          const endpoint =
            document.getElementById('endpoint')?.value?.trim() || window.GRAPHQL_ENDPOINT;
          const confRes = await POST(endpoint, { query: CONFERENCES_QUERY });
          if (confRes.errors) {
            alert('GraphQL error (conferences): ' + JSON.stringify(confRes.errors[0], null, 2));
            return;
          }
          conferenceMeta = confRes.data.conferences || [];
          const res = await POST(endpoint, { query: QUERY, variables: { season } });
          if (res.errors) {
            alert('GraphQL error: ' + JSON.stringify(res.errors[0], null, 2));
            return;
          }
          graphData = res.data;
        }

        buildLegend();
        buildSelectors();
        applyFilters();
      }

      function applyFilters() {
        const typeFilter = document.getElementById('typeFilter').value;
        const minLev = Number(document.getElementById('lev').value);
        document.getElementById('levVal').textContent = String(minLev);
        // Clear path filter when applying filters (show all teams again)
        buildGraph(Number(document.getElementById('season').value), typeFilter, minLev, null);
      }

      document.getElementById('loadBtn').addEventListener('click', load);
      document.getElementById('fitBtn').addEventListener('click', () => cy && cy.fit());
      document.getElementById('lev').addEventListener('input', applyFilters);
      document.getElementById('typeFilter').addEventListener('change', applyFilters);
      document.getElementById('degrees').addEventListener('input', e => {
        document.getElementById('degreesVal').textContent = e.target.value;
      });
      document.getElementById('pathBtn').addEventListener('click', () => {
        const typeFilter = document.getElementById('typeFilter').value;
        const minLev = Number(document.getElementById('lev').value);
        const src = document.getElementById('srcSel').value;
        const dst = document.getElementById('dstSel').value;
        const box = document.getElementById('pathInfo');

        if (!src || !dst) {
          box.textContent = 'Please select both teams.';
          return;
        }

        // First, find the shortest path to determine the minimum degrees needed
        const shortestPath = shortestPathByInverseLeverage(src, dst, typeFilter, minLev);

        if (!shortestPath || shortestPath.nodes.length === 0) {
          box.textContent = 'No path found between these teams (maybe filters are too strict).';
          return;
        }

        // Calculate the number of hops in the shortest path
        // Path nodes include source and dest, so hops = nodes - 1
        const shortestPathHops = shortestPath.nodes.length - 1;

        // Determine appropriate degrees to show based on shortest path
        // If direct connection (1 hop), show degree 1 to see common opponents too
        // Otherwise, show the exact number of hops in the shortest path
        const suggestedDegrees = shortestPathHops === 1 ? 1 : shortestPathHops;

        // Update the degree slider to match the shortest path
        const degreesSlider = document.getElementById('degrees');
        degreesSlider.value = suggestedDegrees;
        document.getElementById('degreesVal').textContent = suggestedDegrees;

        const degrees = suggestedDegrees;

        // Find all nodes within N degrees of both selected teams
        // Pass the shortest path to ensure it's always included
        const res = findNodesWithinDegrees([src, dst], degrees, typeFilter, minLev, shortestPath);

        if (!res || res.nodes.length === 0) {
          box.textContent = 'No connections found (maybe filters are too strict).';
          return;
        }

        // Rebuild graph to show teams within degrees of separation
        const season = Number(document.getElementById('season').value);
        buildGraph(season, typeFilter, minLev, res);

        // Highlight the selected teams
        cy.elements().removeClass('highlight');
        cy.getElementById(src).addClass('highlight');
        cy.getElementById(dst).addClass('highlight');
        cy.style()
          .selector('.highlight')
          .style({ 'background-color': '#facc15', 'border-width': 3, 'border-color': '#fff' })
          .update();

        // Render comparison info
        const frag = document.createDocumentFragment();
        const header = document.createElement('div');
        header.className = 'small muted';
        header.textContent = `Comparison network (${res.nodes.length} teams, ${res.edges.length} connections):`;
        frag.appendChild(header);

        const srcTeam = teamIndex.get(src);
        const dstTeam = teamIndex.get(dst);

        const summary = document.createElement('div');
        summary.style.marginTop = '8px';
        summary.innerHTML = `<strong>${srcTeam.name}</strong> vs <strong>${dstTeam.name}</strong>`;
        frag.appendChild(summary);

        // Show shortest path info
        const pathInfo = document.createElement('div');
        pathInfo.className = 'small muted';
        pathInfo.style.marginTop = '4px';
        const pathTeamNames = shortestPath.nodes.map(id => teamIndex.get(id)?.name || id);
        pathInfo.textContent = `Shortest path (${shortestPathHops} hop${shortestPathHops !== 1 ? 's' : ''}): ${pathTeamNames.join(' → ')}`;
        frag.appendChild(pathInfo);

        // Count teams by degree
        const degreeCount = new Map();
        for (const [node, deg] of res.nodesByDegree) {
          degreeCount.set(deg, (degreeCount.get(deg) || 0) + 1);
        }

        const degreeInfo = document.createElement('div');
        degreeInfo.className = 'small muted';
        degreeInfo.style.marginTop = '6px';
        const degreeParts = [];
        for (let d = 0; d <= degrees; d++) {
          const count = degreeCount.get(d) || 0;
          if (count > 0) {
            degreeParts.push(`${count} at ${d}°`);
          }
        }
        degreeInfo.textContent = 'Distribution: ' + degreeParts.join(', ');
        frag.appendChild(degreeInfo);

        box.replaceChildren(frag);
      });

      // Auto-load will be triggered after static data adapter loads
    </script>
    <script type="module">
      // Load static data adapter first
      import { staticData } from './modules/static-data-adapter.js';
      window.staticDataAdapter = staticData;
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        console.log('[Visualizer] Static data adapter initialized');
      }

      // Trigger the load function that was defined in the previous script
      load();
    </script>
    <script type="module">
      import { initNavigation } from './modules/shared-nav.js';
      initNavigation('fbs-graph');
    </script>
  </body>
</html>
