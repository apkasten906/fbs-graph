<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FBS Schedule Graph — Teams & Matchups</title>
    <link rel="stylesheet" href="common-theme.css" />
    <style>
      * {
        box-sizing: border-box;
      }
      header {
        padding: 10px 12px;
        background: linear-gradient(90deg, #0e1631, #151f43);
        border-bottom: 1px solid #26335f;
        position: sticky;
        top: 0;
        z-index: 5;
      }
      header h1 {
        font-size: 16px;
        margin: 0 0 6px;
        letter-spacing: 0.3px;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      .controls label {
        font-size: 12px;
        color: var(--muted);
      }
      .controls input,
      .controls select,
      .controls button {
        background: #0d1634;
        color: var(--ink);
        border: 1px solid #23315e;
        border-radius: 8px;
        padding: 6px 8px;
        font-size: 12px;
      }
      .controls label.inline {
        display: inline-flex;
        align-items: center;
        gap: 4px;
      }
      .controls input[type='checkbox'] {
        width: 14px;
        height: 14px;
      }
      .controls input[type='range'] {
        width: 160px;
      }
      .controls button {
        cursor: pointer;
        transition: 0.2s background;
      }
      .controls button:hover {
        background: #112058;
      }
      main {
        display: flex;
        height: calc(100vh - 72px);
      }
      #sidebar {
        width: 320px;
        border-right: 1px solid #26335f;
        background: var(--panel);
        padding: 10px;
        overflow: auto;
      }
      #cy {
        flex: 1;
      }
      .legend {
        font-size: 12px;
        display: grid;
        grid-template-columns: 14px 1fr;
        gap: 8px 8px;
        align-items: center;
      }
      .dot {
        width: 12px;
        height: 12px;
        border-radius: 999px;
      }
      .muted {
        color: var(--muted);
      }
      .section {
        margin-bottom: 12px;
      }
      .small {
        font-size: 12px;
      }
      .pathlist {
        font-size: 12px;
        line-height: 1.35;
        max-height: 180px;
        overflow: auto;
        background: #0c1430;
        padding: 8px;
        border: 1px solid #23315e;
        border-radius: 8px;
      }
      .mono {
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New',
          monospace;
      }
      .status {
        font-size: 12px;
        color: var(--muted);
        margin-top: 6px;
      }
      footer {
        position: fixed;
        bottom: 10px;
        left: 10px;
        z-index: 10;
        font-size: 12px;
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <header>
      <h1>FBS Schedule Graph — Teams & Matchups</h1>
      <div class="controls">
        <label>GraphQL:</label>
        <input id="endpoint" value="http://localhost:4100/graphql" size="34" />
        <label>Season:</label>
        <input id="season" type="number" value="2025" style="width: 80px" />
        <label>Type:</label>
        <select id="typeFilter">
          <option value="ALL" selected>All</option>
          <option value="NON_CONFERENCE">Non-Conference</option>
          <option value="CONFERENCE">Conference</option>
        </select>
        <label>Conference:</label>
        <select id="conferenceFilter">
          <option value="ALL" selected>All Conferences</option>
        </select>
        <label>Min leverage:</label>
        <input id="lev" type="range" min="0" max="1.2" step="0.01" value="0" />
        <span id="levVal" class="muted small">0</span>
        <label class="inline"><input type="checkbox" id="hideIsolates" /> Hide isolated</label>
        <button id="loadBtn">Reload</button>
        <button id="fitBtn">Fit</button>
      </div>
    </header>

    <main>
      <aside id="sidebar">
        <div class="section">
          <div class="muted small">
            Find connection between teams (shortest path by 1/leverage):
          </div>
          <div
            style="display: flex; gap: 6px; margin-top: 6px; flex-wrap: wrap; align-items: flex-end"
          >
            <select id="srcSel"></select>
            <select id="dstSel"></select>
          </div>
          <div style="margin-top: 8px">
            <button id="pathBtn">Path</button>
          </div>
          <div id="pathInfo" class="pathlist" style="margin-top: 8px">No path computed yet.</div>
        </div>
        <div class="section">
          <div class="muted small">Focus on a team and explore nearby connections:</div>
          <div
            style="display: flex; gap: 6px; margin-top: 6px; flex-wrap: wrap; align-items: flex-end"
          >
            <select id="focusSel"></select>
            <label class="small" style="display: flex; align-items: center; gap: 4px"
              >Degrees
              <input id="focusDepth" type="number" min="1" max="6" value="2" style="width: 48px" />
            </label>
          </div>
          <div style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap">
            <button id="focusBtn">Focus</button>
            <button id="clearFocusBtn">Clear focus</button>
          </div>
          <div id="focusStatus" class="status"></div>
        </div>
        <div class="section">
          <div class="muted small">Legend / Conferences</div>
          <div id="legend" class="legend" style="margin-top: 6px"></div>
        </div>
        <div class="section small muted">
          Tip: drag nodes, wheel to zoom. Click an edge to see the games that create that
          connection.
        </div>
      </aside>
      <div id="cy"></div>
    </main>

    <footer class="small">Edit endpoint if your server runs elsewhere; set season; Reload.</footer>

    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    <script>
      const COLORS = {
        sec: '#6CCFF6',
        b1g: '#B28DFF',
        b12: '#F6AE2D',
        acc: '#4CC9F0',
        aac: '#FF6B6B',
        mwc: '#80ED99',
        mac: '#FFD166',
        sbc: '#90CAF9',
        cusa: '#FF9E00',
        ind: '#BDB2FF',
        pac12: '#9CCC65',
        other: '#CCD6F6',
      };

      const QUERY = `
query Graph($season: Int!) {
  teams(season: $season) {
    id name shortName conference { id shortName }
  }
  games(season: $season) {
    id type leverage date
    home { id name conference { id shortName } }
    away { id name conference { id shortName } }
  }
}`;

      const POST = (url, body) =>
        fetch(url, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(body),
        }).then(r => r.json());

      let cy;
      let graphData = { teams: [], games: [] };
      let pairGames = new Map(); // key "a__b" -> array of games
      let teamIndex = new Map();

      function key(a, b) {
        return a < b ? a + '__' + b : b + '__' + a;
      }

      function getConferenceId(team) {
        if (!team || !team.conference) return 'ind';
        return team.conference.id || 'ind';
      }

      function buildGraph(season, typeFilter, minLev, conferenceFilter, hideIsolates) {
        const nodeElements = [];
        const edgeElements = [];
        const allowedTeams = new Set();
        const activeTeams = new Set();
        teamIndex.clear();
        graphData.teams.forEach(t => teamIndex.set(t.id, t));

        // Nodes
        for (const t of graphData.teams) {
          const conf = getConferenceId(t);
          if (conferenceFilter !== 'ALL' && conf !== conferenceFilter) continue;
          nodeElements.push({
            group: 'nodes',
            data: { id: t.id, label: t.name, conf, sizeScale: 1 },
            classes: conf,
          });
          allowedTeams.add(t.id);
        }

        // Edge aggregation by pair
        pairGames.clear();
        const edges = new Map();
        for (const g of graphData.games) {
          if (typeFilter !== 'ALL' && g.type !== typeFilter) continue;
          const lev = typeof g.leverage === 'number' ? g.leverage : 0;
          if (lev < minLev) continue;
          const a = g.home.id,
            b = g.away.id;
          if (!teamIndex.has(a) || !teamIndex.has(b)) continue;
          if (conferenceFilter !== 'ALL' && (!allowedTeams.has(a) || !allowedTeams.has(b))) continue;
          const k = key(a, b);
          const arr = pairGames.get(k) || [];
          arr.push(g);
          pairGames.set(k, arr);
        }
        for (const [k, list] of pairGames) {
          // compute edge weight
          const a = list[0].home.id,
            b = list[0].away.id;
          const sumLev = list.reduce((s, x) => s + (x.leverage || 0), 0);
          const avgLev = sumLev / list.length;
          const w = Math.max(1, Math.log2(1 + sumLev * 4));
          edges.set(k, { a, b, count: list.length, sumLev, avgLev, weight: w });
        }
        for (const [k, e] of edges) {
          activeTeams.add(e.a);
          activeTeams.add(e.b);
          edgeElements.push({
            group: 'edges',
            data: {
              id: 'e_' + k,
              source: e.a,
              target: e.b,
              label: `${e.count}`,
              weight: e.weight,
              avgLev: e.avgLev,
            },
          });
        }

        const nodesToUse = hideIsolates
          ? nodeElements.filter(n => activeTeams.has(n.data.id))
          : nodeElements;
        const els = [...nodesToUse, ...edgeElements];

        // Init / update Cytoscape
        if (!cy) {
          cy = cytoscape({
            container: document.getElementById('cy'),
            elements: els,
            layout: { name: 'cose', idealEdgeLength: 120, nodeOverlap: 10 },
            style: [
              {
                selector: 'node',
                style: {
                  'background-color': ele => COLORS[ele.data('conf')] || COLORS.other,
                  label: 'data(label)',
                  color: '#cfe1ff',
                  'font-size': ele => {
                    const scale = ele.data('sizeScale') || 1;
                    return 11 * Math.max(0.55, scale);
                  },
                  'text-outline-color': '#0b1020',
                  'text-outline-width': 2,
                  width: ele => {
                    const deg = ele.data('deg') || 0;
                    const base = 16 + Math.min(18, deg * 1.2);
                    return base * (ele.data('sizeScale') || 1);
                  },
                  height: ele => {
                    const deg = ele.data('deg') || 0;
                    const base = 16 + Math.min(18, deg * 1.2);
                    return base * (ele.data('sizeScale') || 1);
                  },
                },
              },
              {
                selector: 'edge',
                style: {
                  'line-color': '#4562aa',
                  width: ele => Math.max(1.5, ele.data('weight') || 1.5),
                  opacity: 0.7,
                  'curve-style': 'haystack',
                },
              },
              { selector: 'edge:selected', style: { 'line-color': '#fff', opacity: 1 } },
              {
                selector: '.highlight',
                style: { 'line-color': '#fff', 'background-color': '#fff', opacity: 1 },
              },
              {
                selector: '.hidden-node',
                style: { display: 'none' },
              },
              {
                selector: '.hidden-edge',
                style: { display: 'none' },
              },
              {
                selector: '.focus-root',
                style: {
                  'border-width': 2,
                  'border-color': '#ffffff',
                  'background-color': '#ffffff',
                  color: '#0b1020',
                },
              },
              {
                selector: '.focus-related',
                style: {
                  opacity: 1,
                  'text-opacity': 1,
                  'line-color': '#9db6ff',
                  'line-opacity': 0.9,
                },
              },
            ],
          });
          cy.on('tap', 'edge', e => showEdgeGames(e.target().data()));
        } else {
          cy.elements().remove();
          cy.add(els);
        }

        // Compute degree for sizing
        updateNodeMetrics();
        runMainLayout();
      }

      function updateNodeMetrics() {
        if (!cy) return;
        cy.nodes().forEach(n => {
          n.data('deg', n.connectedEdges().length);
          if (typeof n.data('sizeScale') !== 'number') {
            n.data('sizeScale', 1);
          }
        });
      }

      function applyDensityScaling() {
        if (!cy) return;
        const visibleNodes = cy.nodes().filter(n => !n.hasClass('hidden-node'));
        if (!visibleNodes.length) return;
        const maxDist = 90;
        visibleNodes.forEach(n => n.data('sizeScale', 1));
        visibleNodes.forEach(n => {
          const p = n.position();
          let minDist = Infinity;
          visibleNodes.forEach(m => {
            if (n === m) return;
            const mp = m.position();
            const dx = p.x - mp.x;
            const dy = p.y - mp.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDist) minDist = dist;
          });
          if (!isFinite(minDist)) minDist = maxDist;
          const scale = Math.max(0.45, Math.min(1, minDist / maxDist));
          n.data('sizeScale', scale);
        });
        cy.style().update();
      }

      function runMainLayout() {
        if (!cy || cy.elements().length === 0) return;
        const layout = cy.layout({
          name: 'cose',
          idealEdgeLength: 120,
          nodeOverlap: 10,
          animate: false,
          fit: true,
          padding: 80,
        });
        layout.on('layoutstop', () => {
          applyDensityScaling();
        });
        layout.run();
      }

      function resetFocusState() {
        const statusEl = document.getElementById('focusStatus');
        statusEl.textContent = '';
        if (!cy) {
          return;
        }
        cy.batch(() => {
          cy.elements().removeClass('hidden-node hidden-edge focus-root focus-related highlight');
        });
        applyDensityScaling();
      }

      function focusOnTeam() {
        if (!cy) return;
        const teamId = document.getElementById('focusSel').value;
        const depthLimit = Number(document.getElementById('focusDepth').value) || 1;
        const statusEl = document.getElementById('focusStatus');
        const root = cy.getElementById(teamId);
        if (!root || root.empty()) {
          statusEl.textContent = 'Team not visible with the current filters.';
          return;
        }

        const visited = new Map();
        const queue = [{ id: teamId, depth: 0 }];
        visited.set(teamId, 0);

        while (queue.length) {
          const { id, depth } = queue.shift();
          if (depth >= depthLimit) continue;
          const node = cy.getElementById(id);
          node.connectedEdges().forEach(edge => {
            if (edge.hasClass('hidden-edge')) return;
            const connected = edge.connectedNodes();
            connected.forEach(n => {
              const nid = n.id();
              if (nid === id || n.hasClass('hidden-node')) return;
              if (!visited.has(nid)) {
                visited.set(nid, depth + 1);
                queue.push({ id: nid, depth: depth + 1 });
              }
            });
          });
        }

        const focusedNodes = cy.collection();
        visited.forEach((_, id) => {
          const node = cy.getElementById(id);
          if (node && node.length) {
            focusedNodes.merge(node);
          }
        });
        if (!focusedNodes.length) {
          statusEl.textContent = 'No connected teams found within that separation.';
          return;
        }

        const focusedEdges = cy.edges().filter(edge => {
          const src = edge.source().id();
          const tgt = edge.target().id();
          return visited.has(src) && visited.has(tgt);
        });

        cy.batch(() => {
          cy.elements().removeClass('hidden-node hidden-edge focus-root focus-related highlight');
          cy.nodes().forEach(node => {
            if (!visited.has(node.id())) {
              node.addClass('hidden-node');
            } else {
              node.addClass('focus-related');
            }
          });
          cy.edges().forEach(edge => {
            if (!visited.has(edge.source().id()) || !visited.has(edge.target().id())) {
              edge.addClass('hidden-edge');
            } else {
              edge.addClass('focus-related');
            }
          });
          root.addClass('focus-root');
        });

        const maxDepth = Math.max(...visited.values());
        const layout = cy.layout({
          name: 'concentric',
          fit: true,
          animate: true,
          padding: 100,
          sweep: Math.PI * 2,
          startAngle: (3 / 2) * Math.PI,
          concentric: node => maxDepth - (visited.get(node.id()) || maxDepth),
          levelWidth: () => 1,
          eles: focusedNodes.union(focusedEdges),
        });
        layout.on('layoutstop', () => {
          applyDensityScaling();
          const shownDepth = Math.min(maxDepth, depthLimit);
          statusEl.textContent = `Showing ${focusedNodes.length} teams within ${shownDepth} degree${
            shownDepth === 1 ? '' : 's'
          } of separation.`;
        });
        layout.run();
      }

      function showEdgeGames(data) {
        const { id } = data;
        const [_, k] = id.split('e_');
        const games = pairGames.get(k) || [];
        const lines = [];
        lines.push(`<div class="small muted">Games on this connection (${games.length}):</div>`);
        for (const g of games.slice().sort((a, b) => (a.date || '').localeCompare(b.date || ''))) {
          const when = g.date ? new Date(g.date).toLocaleString() : 'TBD';
          lines.push(
            `<div class="mono">${when} — ${g.home.name} vs ${g.away.name} <span class="muted">(lev ${Number(g.leverage || 0).toFixed(3)})</span></div>`
          );
        }
        document.getElementById('pathInfo').innerHTML = lines.join('');
      }

      // Conference metadata cache (populated from GraphQL)
      let conferenceMeta = [];

      function conferenceLabel(id) {
        if (!id) return 'Unknown';
        if (id === 'ind') return 'Independents';
        const meta = conferenceMeta.find(c => c.id === id);
        if (meta) {
          return meta.shortName ? `${meta.name} (${meta.shortName})` : meta.name;
        }
        if (id === 'other') return 'Other / TBD';
        return id.toUpperCase();
      }

      function buildLegend(activeFilter = 'ALL') {
        const container = document.getElementById('legend');
        container.innerHTML = '';
        const seen = new Set();
        // Collect all conferences present in the data
        for (const t of graphData.teams) {
          const conf = getConferenceId(t);
          if (activeFilter !== 'ALL' && conf !== activeFilter) continue;
          seen.add(conf);
        }
        // Map to full names, filter, and sort
        const legendEntries = Array.from(seen)
          .map(id => {
            return {
              id,
              color: COLORS[id] || COLORS.other,
              label: conferenceLabel(id),
              sortKey: conferenceLabel(id),
            };
          })
          .sort((a, b) => a.sortKey.localeCompare(b.sortKey));
        for (const entry of legendEntries) {
          const dot = document.createElement('div');
          dot.className = 'dot';
          dot.style.background = entry.color;
          const lbl = document.createElement('div');
          lbl.textContent = entry.label;
          container.appendChild(dot);
          container.appendChild(lbl);
        }
      }

      function buildSelectors() {
        const srcSel = document.getElementById('srcSel');
        const dstSel = document.getElementById('dstSel');
        const focusSel = document.getElementById('focusSel');
        const prevSrc = srcSel.value;
        const prevDst = dstSel.value;
        const prevFocus = focusSel.value;
        const opts = graphData.teams.slice().sort((a, b) => a.name.localeCompare(b.name));
        srcSel.innerHTML = '';
        dstSel.innerHTML = '';
        focusSel.innerHTML = '';
        for (const t of opts) {
          const o1 = document.createElement('option');
          o1.value = t.id;
          o1.textContent = t.name;
          srcSel.appendChild(o1);
          const o2 = document.createElement('option');
          o2.value = t.id;
          o2.textContent = t.name;
          dstSel.appendChild(o2);
          const o3 = document.createElement('option');
          o3.value = t.id;
          o3.textContent = t.name;
          focusSel.appendChild(o3);
        }
        if (prevSrc) srcSel.value = prevSrc;
        if (prevDst) dstSel.value = prevDst;
        if (prevFocus) focusSel.value = prevFocus;
      }

      function populateConferenceFilter() {
        const select = document.getElementById('conferenceFilter');
        const previous = select.value;
        const seen = new Map();
        conferenceMeta.forEach(c => {
          seen.set(c.id, conferenceLabel(c.id));
        });
        graphData.teams.forEach(team => {
          const id = getConferenceId(team);
          if (!seen.has(id)) {
            seen.set(id, conferenceLabel(id));
          }
        });
        const options = Array.from(seen.entries())
          .map(([value, label]) => ({ value, label }))
          .sort((a, b) => a.label.localeCompare(b.label));
        select.innerHTML = '';
        const allOpt = document.createElement('option');
        allOpt.value = 'ALL';
        allOpt.textContent = 'All Conferences';
        select.appendChild(allOpt);
        for (const opt of options) {
          const option = document.createElement('option');
          option.value = opt.value;
          option.textContent = opt.label;
          select.appendChild(option);
        }
        if (previous && previous !== 'ALL') {
          select.value = previous;
          if (select.value !== previous) {
            select.value = 'ALL';
          }
        }
      }

      function shortestPathByInverseLeverage(srcId, dstId, typeFilter, minLev) {
        // Build adjacency with weight = 1 / (avg leverage of pair). If multiple games per pair, we use avg.
        const adj = new Map();
        for (const [k, list] of pairGames) {
          const a = list[0].home.id,
            b = list[0].away.id;
          const filtered = list.filter(
            g => (typeFilter === 'ALL' || g.type === typeFilter) && (g.leverage || 0) >= minLev
          );
          if (!filtered.length) continue;
          const avg = filtered.reduce((s, x) => s + (x.leverage || 0), 0) / filtered.length;
          const w = 1 / Math.max(1e-6, avg);
          if (!adj.has(a)) adj.set(a, []);
          if (!adj.has(b)) adj.set(b, []);
          adj.get(a).push({ to: b, k, w, avg, games: filtered });
          adj.get(b).push({ to: a, k, w, avg, games: filtered });
        }
        // Dijkstra
        const dist = new Map(),
          prev = new Map(),
          prevEdge = new Map();
        const allIds = Array.from(graphData.teams, t => t.id);
        const Q = new Set(allIds);
        for (const id of allIds) dist.set(id, Infinity);
        dist.set(srcId, 0);
        while (Q.size) {
          let u = null,
            best = Infinity;
          for (const v of Q) {
            const d = dist.get(v);
            if (d < best) {
              best = d;
              u = v;
            }
          }
          if (u === null || best === Infinity) break;
          Q.delete(u);
          if (u === dstId) break;
          const nbrs = adj.get(u) || [];
          for (const e of nbrs) {
            if (!Q.has(e.to)) continue;
            const alt = dist.get(u) + e.w;
            if (alt < dist.get(e.to)) {
              dist.set(e.to, alt);
              prev.set(e.to, u);
              prevEdge.set(e.to, e.k);
            }
          }
        }
        if (!prev.has(dstId)) return null;
        // Rebuild path
        const pathIds = [];
        const edges = [];
        let cur = dstId;
        while (cur !== srcId) {
          pathIds.push(cur);
          edges.push(prevEdge.get(cur));
          cur = prev.get(cur);
        }
        pathIds.push(srcId);
        pathIds.reverse();
        edges.reverse();
        return { nodes: pathIds, edges };
      }

      const CONFERENCES_QUERY = `
        query { conferences { id name shortName } }
      `;

      async function load() {
        const endpoint = document.getElementById('endpoint').value.trim();
        const season = Number(document.getElementById('season').value);
        // Fetch conference metadata first
        const confRes = await POST(endpoint, { query: CONFERENCES_QUERY });
        if (confRes.errors) {
          alert('GraphQL error (conferences): ' + JSON.stringify(confRes.errors[0], null, 2));
          return;
        }
        conferenceMeta = confRes.data.conferences || [];
        // Now fetch main graph data
        const res = await POST(endpoint, { query: QUERY, variables: { season } });
        if (res.errors) {
          alert('GraphQL error: ' + JSON.stringify(res.errors[0], null, 2));
          return;
        }
        graphData = res.data;
        buildLegend();
        buildSelectors();
        populateConferenceFilter();
        applyFilters();
      }

      function applyFilters() {
        const typeFilter = document.getElementById('typeFilter').value;
        const minLev = Number(document.getElementById('lev').value);
        const conferenceFilter = document.getElementById('conferenceFilter').value;
        const hideIsolates = document.getElementById('hideIsolates').checked;
        document.getElementById('levVal').textContent = minLev.toFixed(2);
        resetFocusState();
        buildGraph(
          Number(document.getElementById('season').value),
          typeFilter,
          minLev,
          conferenceFilter,
          hideIsolates
        );
        buildLegend(conferenceFilter);
      }

      document.getElementById('loadBtn').addEventListener('click', load);
      document.getElementById('fitBtn').addEventListener('click', () => cy && cy.fit());
      document.getElementById('lev').addEventListener('input', applyFilters);
      document.getElementById('typeFilter').addEventListener('change', applyFilters);
      document.getElementById('conferenceFilter').addEventListener('change', applyFilters);
      document.getElementById('hideIsolates').addEventListener('change', applyFilters);
      document.getElementById('pathBtn').addEventListener('click', () => {
        resetFocusState();
        const typeFilter = document.getElementById('typeFilter').value;
        const minLev = Number(document.getElementById('lev').value);
        const src = document.getElementById('srcSel').value;
        const dst = document.getElementById('dstSel').value;
        const res = shortestPathByInverseLeverage(src, dst, typeFilter, minLev);
        const box = document.getElementById('pathInfo');
        if (!res) {
          box.textContent = 'No path found (maybe filters are too strict).';
          return;
        }
        // Highlight
        cy.elements().removeClass('highlight');
        const elist = [];
        for (const id of res.nodes) elist.push(cy.getElementById(id));
        for (const k of res.edges) elist.push(cy.getElementById('e_' + k));
        elist.forEach(e => e.addClass('highlight'));
        cy.style()
          .selector('.highlight')
          .style({ 'line-color': '#fff', 'background-color': '#fff' })
          .update();
        // Render path with game details
        const lines = [];
        lines.push(`<div class="small muted">Shortest connection (by 1/leverage):</div>`);
        for (let i = 0; i < res.nodes.length; i++) {
          const id = res.nodes[i];
          const t = teamIndex.get(id);
          lines.push(`<div>${t.name}${i < res.nodes.length - 1 ? ' → ' : ''}</div>`);
          if (i < res.nodes.length - 1) {
            const k = res.edges[i];
            const games = pairGames.get(k) || [];
            const top = games
              .slice()
              .sort((a, b) => (b.leverage || 0) - (a.leverage || 0))
              .slice(0, 3);
            lines.push(
              `<div class="muted small" style="margin:4px 0 6px 8px">Top games on this edge:</div>`
            );
            for (const g of top) {
              const when = g.date ? new Date(g.date).toLocaleDateString() : 'TBD';
              lines.push(
                `<div class="mono" style="margin-left:8px">${when} — ${g.home.name} vs ${g.away.name} (lev ${Number(g.leverage || 0).toFixed(3)})</div>`
              );
            }
          }
        }
        box.innerHTML = lines.join('');
      });

      document.getElementById('focusBtn').addEventListener('click', focusOnTeam);
      document.getElementById('clearFocusBtn').addEventListener('click', () => {
        resetFocusState();
        runMainLayout();
      });

      // Auto-load on start
      load();
    </script>
  </body>
</html>
